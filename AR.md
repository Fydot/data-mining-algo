频繁模式、关联和相关算法
===


#1、Apriori

算法介绍
	
	Apriori 算法，解决了单纬度、单层次、bool 频繁频繁项集。是1994年由 R.Agrawal 和 R.Srikant 提出的。
	

算法过程
	
	算法思想可以用一句话来描述，按照频繁模式的项集个数分层，采用宽度优先的方式，逐层搜索频繁模式，例如首先搜索1项集的频繁模式，然后利用1项集的结果，将结果之间连接，在 k=2 的层次上搜索，即 k 项集的频繁模式由k-1项集的频繁模式计算而来，我们称之为基于先验知识
	

性质：

	按照上面的介绍，实际上这种算法的时间复杂度是很高的，所以我们必须对算法进行优化，这里我们通过观察，会发现一个很有用的性质：
		* 频繁项集的所有非空子集也必须是频繁的 *
	根据定义，所有项集 I 不满足最小支持度阀值 min_sup，则 I 不是频繁的，即 P(I) < min_sup, 若将 A 添加到项集 I 中，其中 A 不属于 I，则 P(I U A) = P(A) * P(I) < P(I) << min_sup。上述性质称为 Apriori 性质，这类性质称之为反单调性
	
步骤
	
	我们将整个算法分为两个步骤：
	* 连接：为了找到 L(k) ,通过将 L(K-1)与自身连接产生候选 k 项集。改候选项集记作


优化

	
	*剪枝，利用 Apriori 性质

		反单调性，若 I 不是频繁项集，则 I 的超集必然也不是频繁项集

	*利用散列表

		在扫描 L(k-1)的时候，利用散列表计算出 C(k)的支持度

	*压缩事物

		利用 Apriori 算法的性质，不包含频繁项集的事物可以不再扫描

	*划分

		将事物数据库数据划分，计算局部的频繁项集


#2、FP增长

将数据库压缩到 FP 树，，利用前缀


#3、垂直数据格式算法

将水平食物数据库数据垂直化

#4、相关分析

##出现原因：

负相关，产生误导关联

##检测方法

###提升度

	lift(A,B) = P(A U B) / (P(A) * P(B))
	
###χ2度量

	χ2 = Sum((观测值-期望值)^2 / 期望值)

###全置信度

	all_conf(X) = sup(X) / max_item_sup(X)
	
	== confidence of i => X - i (i 为 X 中的一个项)
	
	##可简单推导出来
	
###余弦定理

	cosine(A, B) = P(A U B) / Sqrt(P(A) * P(B))

一种好的策略是，先进行全置信度或者余弦分析，并且当结果显示他们是弱相关时，进行其他分析，以帮助得到更完整的描述
